{
    "comparisons.image.CompareLoad.peakmem_compare_load": {
        "code": "class CompareLoad:\n    def peakmem_compare_load(self, loader):\n        \"\"\"Peak memory of loading images.\"\"\"\n        load(loader)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "comparisons.image.CompareLoad.peakmem_compare_load",
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "setup_cache_key": "common:14",
        "type": "peakmemory",
        "unit": "bytes",
        "version": "88f7a490bc9b3f6a2081e6eb30be46f3b0cc39b58d8f81b02894c8fbe2271587"
    },
    "comparisons.image.CompareLoad.time_compare_load": {
        "code": "class CompareLoad:\n    def time_compare_load(self, loader):\n        \"\"\"Time the loading of images.\"\"\"\n        load(loader)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "comparisons.image.CompareLoad.time_compare_load",
        "number": 0,
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:14",
        "type": "time",
        "unit": "seconds",
        "version": "2994af8c61f898ec0be0b407cbf6dd6b837bb56af9adb4ed7a1020455d5d339e",
        "warmup_time": -1
    },
    "comparisons.image.CompareMean.peakmem_compare_mean": {
        "code": "class CompareMean:\n    def peakmem_compare_mean(self, loader):\n        \"\"\"Peak memory of loading followed by taking the mean.\"\"\"\n        img = load(loader)[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "comparisons.image.CompareMean.peakmem_compare_mean",
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "setup_cache_key": "common:14",
        "type": "peakmemory",
        "unit": "bytes",
        "version": "77baec0c0627028bf743ee9f749a566f9ab02f3173de8f2a66b6bc2437cd238a"
    },
    "comparisons.image.CompareMean.time_compare_mean": {
        "code": "class CompareMean:\n    def time_compare_mean(self, loader):\n        \"\"\"Time the loading followed by taking the mean.\"\"\"\n        img = load(loader)[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "comparisons.image.CompareMean.time_compare_mean",
        "number": 0,
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:14",
        "type": "time",
        "unit": "seconds",
        "version": "94952f83533b7a86222f46b1aeae754307f5c4ce981b4a494b95f57f14d6069c",
        "warmup_time": -1
    },
    "comparisons.image.CompareSlice.peakmem_compare_slice": {
        "code": "class CompareSlice:\n    def peakmem_compare_slice(self, loader):\n        \"\"\"Peak memory of loading the image followed by extracting a\n        slice of it.\n        \"\"\"\n        img = load(loader)[1]\n        img.dataobj[..., 0]\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "comparisons.image.CompareSlice.peakmem_compare_slice",
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "setup_cache_key": "common:14",
        "type": "peakmemory",
        "unit": "bytes",
        "version": "4c8fe6adb47a7d17ef9a1dc262aa392cc1b53c7d9c972183a5c1228c8883f435"
    },
    "comparisons.image.CompareSlice.time_compare_slice": {
        "code": "class CompareSlice:\n    def time_compare_slice(self, loader):\n        \"\"\"Time the loading the image followed by extracting a slice of it.\"\"\"\n        img = load(loader)[1]\n        img.dataobj[..., 0]\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "comparisons.image.CompareSlice.time_compare_slice",
        "number": 0,
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:14",
        "type": "time",
        "unit": "seconds",
        "version": "3fbfb37876bac533ad2bea0fd583fe2d4bdb261346ce29e935c87ab8e5828799",
        "warmup_time": -1
    },
    "comparisons.maskers.CompareMask.peakmem_compare_mask": {
        "code": "class CompareMask:\n    def peakmem_compare_mask(self, implementation, loader):\n        \"\"\"Peak memory of loading and then masking.\"\"\"\n        mask, img = load(loader)\n        apply_mask(mask, img, implementation)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "comparisons.maskers.CompareMask.peakmem_compare_mask",
        "param_names": [
            "implementation",
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'numpy (ref)'"
            ],
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "setup_cache_key": "common:14",
        "type": "peakmemory",
        "unit": "bytes",
        "version": "13c162044f6eee63259e973ecadbfbd8fe5aaa1e0f9f91a350b4c3bb7cb9d403"
    },
    "comparisons.maskers.CompareMask.time_compare_mask": {
        "code": "class CompareMask:\n    def time_compare_mask(self, implementation, loader):\n        \"\"\"Time the loading and then masking.\"\"\"\n        mask, img = load(loader)\n        apply_mask(mask, img, implementation)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "comparisons.maskers.CompareMask.time_compare_mask",
        "number": 0,
        "param_names": [
            "implementation",
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'numpy (ref)'"
            ],
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:14",
        "type": "time",
        "unit": "seconds",
        "version": "0b059e866988927152e8940212e5b5726099ac510fce609a3e443a98866eb3c2",
        "warmup_time": -1
    },
    "tracking.image.LoadImgBenchmark.peakmem_load_img": {
        "code": "class LoadImgBenchmark:\n    def peakmem_load_img(self):\n        \"\"\"Peak memory of loading images.\"\"\"\n        load(\"nilearn\")\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "tracking.image.LoadImgBenchmark.peakmem_load_img",
        "param_names": [],
        "params": [],
        "setup_cache_key": "common:14",
        "type": "peakmemory",
        "unit": "bytes",
        "version": "17befdc559abbf09bea0b0a1da933363cfd62d51ea819f9f4abb9140974b2f37"
    },
    "tracking.image.LoadImgBenchmark.time_load_img": {
        "code": "class LoadImgBenchmark:\n    def time_load_img(self):\n        \"\"\"Time the loading of images.\"\"\"\n        load(\"nilearn\")\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "tracking.image.LoadImgBenchmark.time_load_img",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:14",
        "type": "time",
        "unit": "seconds",
        "version": "9844655ec215e04c37085aa1c3a9c3734a633e88f5ab55c75d4785ed241158bf",
        "warmup_time": -1
    },
    "tracking.image.MeanImgBenchmark.peakmem_mean_img": {
        "code": "class MeanImgBenchmark:\n    def peakmem_mean_img(self):\n        \"\"\"Peak memory of loading followed by taking the mean.\"\"\"\n        img = load(\"nilearn\")[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "tracking.image.MeanImgBenchmark.peakmem_mean_img",
        "param_names": [],
        "params": [],
        "setup_cache_key": "common:14",
        "type": "peakmemory",
        "unit": "bytes",
        "version": "d5ff9d910336a19a7a3c194fa4b2f70d195f302c3eddf250ade1727176f09a83"
    },
    "tracking.image.MeanImgBenchmark.time_mean_img": {
        "code": "class MeanImgBenchmark:\n    def time_mean_img(self):\n        \"\"\"Time the loading followed by taking the mean.\"\"\"\n        img = load(\"nilearn\")[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "tracking.image.MeanImgBenchmark.time_mean_img",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:14",
        "type": "time",
        "unit": "seconds",
        "version": "eed3a40822bc017b986af5fc900897fc797899c863bb89a3aaddac0548c12c54",
        "warmup_time": -1
    },
    "tracking.maskers.NiftiMaskerBenchmark.peakmem_nifti_masker": {
        "code": "class NiftiMaskerBenchmark:\n    def peakmem_nifti_masker(self, smoothing_fwhm, detrend):\n        \"\"\"Peak memory for the loading (only with nilearn here) and then\n        masking with different parameters.\n        \"\"\"\n        mask, img = load(\"nilearn\")\n        apply_mask(\n            mask,\n            img,\n            \"nilearn\",\n            nifti_masker_params={\n                \"smoothing_fwhm\": smoothing_fwhm,\n                \"detrend\": detrend,\n            },\n        )\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "tracking.maskers.NiftiMaskerBenchmark.peakmem_nifti_masker",
        "param_names": [
            "smoothing_fwhm",
            "detrend"
        ],
        "params": [
            [
                "None",
                "6"
            ],
            [
                "False",
                "True"
            ]
        ],
        "setup_cache_key": "common:14",
        "type": "peakmemory",
        "unit": "bytes",
        "version": "6a195fee9be628ba6495554adfa477f474e88d6c55af7dd36cf09f152e3e4007"
    },
    "tracking.maskers.NiftiMaskerBenchmark.time_nifti_masker": {
        "code": "class NiftiMaskerBenchmark:\n    def time_nifti_masker(self, smoothing_fwhm, detrend):\n        \"\"\"Time the loading (only with nilearn here) and then masking with\n        different parameters.\n        \"\"\"\n        mask, img = load(\"nilearn\")\n        apply_mask(\n            mask,\n            img,\n            \"nilearn\",\n            nifti_masker_params={\n                \"smoothing_fwhm\": smoothing_fwhm,\n                \"detrend\": detrend,\n            },\n        )\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "tracking.maskers.NiftiMaskerBenchmark.time_nifti_masker",
        "number": 0,
        "param_names": [
            "smoothing_fwhm",
            "detrend"
        ],
        "params": [
            [
                "None",
                "6"
            ],
            [
                "False",
                "True"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:14",
        "type": "time",
        "unit": "seconds",
        "version": "a449cca679e6a361199de5c25da138905a3b5e1307083cded983792db8192cf5",
        "warmup_time": -1
    },
    "version": 2
}