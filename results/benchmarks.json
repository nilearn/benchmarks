{
    "comparisons.image.CompareLoad.peakmem_compare_load": {
        "code": "class CompareLoad:\n    def peakmem_compare_load(self, loader):\n        \"\"\"Peak memory of loading images.\"\"\"\n        load(loader)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "comparisons.image.CompareLoad.peakmem_compare_load",
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "8cccd33405e98e86fd02530c287e63e0f5984c2970dbe879daba23610bc8037a"
    },
    "comparisons.image.CompareLoad.time_compare_load": {
        "code": "class CompareLoad:\n    def time_compare_load(self, loader):\n        \"\"\"Time the loading of images.\"\"\"\n        load(loader)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "comparisons.image.CompareLoad.time_compare_load",
        "number": 0,
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "time",
        "unit": "seconds",
        "version": "f7ebd1c19cb7bd7c3f174e6d7aaafbfe118df72a2776d07319edd9741de2f1c8",
        "warmup_time": -1
    },
    "comparisons.image.CompareMean.peakmem_compare_mean": {
        "code": "class CompareMean:\n    def peakmem_compare_mean(self, loader):\n        \"\"\"Peak memory of loading followed by taking the mean.\"\"\"\n        img = load(loader)[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "comparisons.image.CompareMean.peakmem_compare_mean",
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "4829e06b6a81223e0d105cf23f99725db306e945a47e1837e3868df1beb46bf7"
    },
    "comparisons.image.CompareMean.time_compare_mean": {
        "code": "class CompareMean:\n    def time_compare_mean(self, loader):\n        \"\"\"Time the loading followed by taking the mean.\"\"\"\n        img = load(loader)[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "comparisons.image.CompareMean.time_compare_mean",
        "number": 0,
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "time",
        "unit": "seconds",
        "version": "6741e954376dfc9d9cc2603e87593eed5525ec868ee1eb4497faf69ba6c2b3b7",
        "warmup_time": -1
    },
    "comparisons.image.CompareSlice.peakmem_compare_slice": {
        "code": "class CompareSlice:\n    def peakmem_compare_slice(self, loader):\n        \"\"\"Peak memory of loading the image followed by extracting a\n        slice of it.\n        \"\"\"\n        img = load(loader)[1]\n        img.dataobj[..., 0]\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "comparisons.image.CompareSlice.peakmem_compare_slice",
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "d90c6926493f5cf0a7b7af6e5b261d1cb1cd0651fa7709b4f2479e879a326a8a"
    },
    "comparisons.image.CompareSlice.time_compare_slice": {
        "code": "class CompareSlice:\n    def time_compare_slice(self, loader):\n        \"\"\"Time the loading the image followed by extracting a slice of it.\"\"\"\n        img = load(loader)[1]\n        img.dataobj[..., 0]\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "comparisons.image.CompareSlice.time_compare_slice",
        "number": 0,
        "param_names": [
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "time",
        "unit": "seconds",
        "version": "098b9a321cf43acb756e78a69ef9fbc05e21f746a4735ca1b6ddb98fa17ee635",
        "warmup_time": -1
    },
    "comparisons.maskers.CompareMask.peakmem_compare_mask": {
        "code": "class CompareMask:\n    def peakmem_compare_mask(self, implementation, loader):\n        \"\"\"Peak memory of loading and then masking.\"\"\"\n        mask, img = load(loader)\n        apply_mask(mask, img, implementation)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "comparisons.maskers.CompareMask.peakmem_compare_mask",
        "param_names": [
            "implementation",
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'numpy (ref)'"
            ],
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "e43932744b77671df15c12bf2827acc772bfc9c7767bbb313e69eb2420600cdc"
    },
    "comparisons.maskers.CompareMask.time_compare_mask": {
        "code": "class CompareMask:\n    def time_compare_mask(self, implementation, loader):\n        \"\"\"Time the loading and then masking.\"\"\"\n        mask, img = load(loader)\n        apply_mask(mask, img, implementation)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "comparisons.maskers.CompareMask.time_compare_mask",
        "number": 0,
        "param_names": [
            "implementation",
            "loader"
        ],
        "params": [
            [
                "'nilearn'",
                "'numpy (ref)'"
            ],
            [
                "'nilearn'",
                "'nibabel (ref)'"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "time",
        "unit": "seconds",
        "version": "0e21f2a9e83d0f3da12cf2ef5cf15a2571204cc9dafe91c9e2daf783dc6c5e11",
        "warmup_time": -1
    },
    "tracking.image.IndexImgBenchmark.peakmem_index_img": {
        "code": "class IndexImgBenchmark:\n    def peakmem_index_img(self):\n        \"\"\"Peak memory of loading the image followed by indexing a voxel.\"\"\"\n        index_img(\"fmri_100.nii.gz\", slice(1, 90, 2))\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "tracking.image.IndexImgBenchmark.peakmem_index_img",
        "param_names": [],
        "params": [],
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "e52f02584aa25628227eaaed2127d9709b756990c494dec8861433a05c54eea1"
    },
    "tracking.image.IndexImgBenchmark.time_index_img": {
        "code": "class IndexImgBenchmark:\n    def time_index_img(self):\n        \"\"\"Time the loading the image followed by indexing a voxel.\"\"\"\n        index_img(\"fmri_100.nii.gz\", slice(1, 90, 2))\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "tracking.image.IndexImgBenchmark.time_index_img",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "time",
        "unit": "seconds",
        "version": "8d512ba85986b57bd49a34cbf3b25a269911e52421ab78623d9f1f742ff6bc91",
        "warmup_time": -1
    },
    "tracking.image.LoadImgBenchmark.peakmem_load_img": {
        "code": "class LoadImgBenchmark:\n    def peakmem_load_img(self):\n        \"\"\"Peak memory of loading images.\"\"\"\n        load(\"nilearn\")\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "tracking.image.LoadImgBenchmark.peakmem_load_img",
        "param_names": [],
        "params": [],
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "89c75c7c51b9633073ab84cd177d8beb3c10fefdd097774e99448fce48d0d8e5"
    },
    "tracking.image.LoadImgBenchmark.time_load_img": {
        "code": "class LoadImgBenchmark:\n    def time_load_img(self):\n        \"\"\"Time the loading of images.\"\"\"\n        load(\"nilearn\")\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "tracking.image.LoadImgBenchmark.time_load_img",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "time",
        "unit": "seconds",
        "version": "7df5e0f711017c90532729605f7067e0bd1e45d20d131739924af5daa4bd05b3",
        "warmup_time": -1
    },
    "tracking.image.MeanImgBenchmark.peakmem_mean_img": {
        "code": "class MeanImgBenchmark:\n    def peakmem_mean_img(self):\n        \"\"\"Peak memory of loading followed by taking the mean.\"\"\"\n        img = load(\"nilearn\")[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "tracking.image.MeanImgBenchmark.peakmem_mean_img",
        "param_names": [],
        "params": [],
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "c7bcd8563e4498c7daea898a08aff3ed14d673bae3644c14c7f09993d6734b0e"
    },
    "tracking.image.MeanImgBenchmark.time_mean_img": {
        "code": "class MeanImgBenchmark:\n    def time_mean_img(self):\n        \"\"\"Time the loading followed by taking the mean.\"\"\"\n        img = load(\"nilearn\")[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "tracking.image.MeanImgBenchmark.time_mean_img",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "time",
        "unit": "seconds",
        "version": "c2c9994af646d4b579d2365b1d1f973143fb48cdd636e248b3a8f2e880e07aba",
        "warmup_time": -1
    },
    "tracking.maskers.NiftiMaskerBenchmark.peakmem_nifti_masker": {
        "code": "class NiftiMaskerBenchmark:\n    def peakmem_nifti_masker(self, smoothing_fwhm, detrend):\n        \"\"\"Peak memory for the loading (only with nilearn here) and then\n        masking with different parameters.\n        \"\"\"\n        mask, img = load(\"nilearn\")\n        apply_mask(\n            mask,\n            img,\n            \"nilearn\",\n            nifti_masker_params={\n                \"smoothing_fwhm\": smoothing_fwhm,\n                \"detrend\": detrend,\n            },\n        )\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "name": "tracking.maskers.NiftiMaskerBenchmark.peakmem_nifti_masker",
        "param_names": [
            "smoothing_fwhm",
            "detrend"
        ],
        "params": [
            [
                "None",
                "6"
            ],
            [
                "False",
                "True"
            ]
        ],
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "peakmemory",
        "unit": "bytes",
        "version": "a1d081b0f3af02abe8e7d42fd9bb9422e633245f89ad12ec8e3cb2527a7f0b0a"
    },
    "tracking.maskers.NiftiMaskerBenchmark.time_nifti_masker": {
        "code": "class NiftiMaskerBenchmark:\n    def time_nifti_masker(self, smoothing_fwhm, detrend):\n        \"\"\"Time the loading (only with nilearn here) and then masking with\n        different parameters.\n        \"\"\"\n        mask, img = load(\"nilearn\")\n        apply_mask(\n            mask,\n            img,\n            \"nilearn\",\n            nifti_masker_params={\n                \"smoothing_fwhm\": smoothing_fwhm,\n                \"detrend\": detrend,\n            },\n        )\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_abide_pcp`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_schaefer_2018` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_abide_pcp(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func_preproc)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")",
        "min_run_count": 2,
        "name": "tracking.maskers.NiftiMaskerBenchmark.time_nifti_masker",
        "number": 0,
        "param_names": [
            "smoothing_fwhm",
            "detrend"
        ],
        "params": [
            [
                "None",
                "6"
            ],
            [
                "False",
                "True"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "setup_cache_key": "common:16",
        "timeout": 2400,
        "type": "time",
        "unit": "seconds",
        "version": "dc02acc52073eeaec42aac9149ca9a24743035f289c5f9d143604d559613a5c3",
        "warmup_time": -1
    },
    "version": 2
}