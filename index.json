{"project": "nilearn", "project_url": "https://nilearn.github.io", "show_commit_url": "https://github.com/nilearn/nilearn/commit/", "hash_length": 8, "revision_to_hash": {"2709": "58fb3d058907a709caed14946e3a3410c1240161", "2778": "fde10ae71ab9df9adb4e4b11d9dff8a0775bd8e7", "3092": "6854e29ba97ccd42b3052e5bf446077ef3558cf5", "3252": "5c9709cc131ed46913ed454a16cbb1e25bfa4592", "3288": "1bdb686ca238f9f147641870854a783579f7a1a5", "3833": "c6b03f2ea7c75a3d80ff25b2d6c1b7dfe9dc18a8", "4133": "22eb0c2949a4167e7796b11b71d2fcff7f9c94a9", "4147": "20a05bead3b3e7f5f5c49926b858cc7ea4b5413b", "4152": "4cacc465c12a38009c330d036f0d278d01724e8a", "6154": "c4898338cba608d37f552d4f3fffe1261e6a07bf", "6158": "4199ed9c8cc3ec548793c1c734bb846d173bee32", "6347": "e5fef38140a688b374b383db6296c12ea945786e", "6419": "96a3f0f72b4f25af771116251324cbec4c0d2055", "6717": "070d3929431897ec175b4b2c869826959dda85ab", "6989": "4988bd761e9ba98ac784d6f99c4a9adf3f79227f", "7188": "67278ac891b599e592ea33a049d89b47e2fc44ce", "7314": "22ac1ae6e9925ddefdb849cd2e6981e4d1947aeb", "7317": "f1cc501a9bc7aafecdbe1fa4047a0a8aa3fa541f", "7319": "c5895f6ea864f042683cdf24e517694785fdca10", "7902": "58d4a33ad5f0fca7004790717988a5232e195666", "8201": "d2b5a93567aa49dd246acac443415dad86130b2b", "8313": "a894d6d931fe7c2b9341dcad228d364ac9580cd3", "8727": "627be2dc74c793b4d489ba62931288d8b71ef401", "8908": "972b8c12ee021f9c362f9b1cd165610ad8f5172a", "9015": "b4f71e5cb31fb0bef2eb9e253706d486edcec95a", "9433": "0b013683b96df6f8fb0124467e820e1326a25489", "9477": "0d2d692938662d54f42ebc1fc67c8f9729bdb73f", "9757": "4be29274fae131b36052c7f1c087b10f7deec519", "9910": "05ca61701ede4e82989d94eaa8b1ef5909b9ccaf", "10115": "61f469058dd16f64df4bc95cdd0d29e44b55d020", "10615": "4ff9717a8d9faa873c2e4137e8445a76865e7c56", "10929": "bccf672b5bbd12274c0504b7c35c75058ccc7e70", "11849": "7e09df29d06153b7d198f9a5b7f607d1f5b999d6", "11904": "b74b496bade616be483449c6da33c7c87e27cc77", "11988": "0941897aca6f3073221fcd3483afe91b8305b27c", "12194": "5acb6570832f2870bdd77b0a71a3b063540de5f9", "12308": "324935c0f4a8743ad82e8a3a3052e010fb10b855", "12417": "9835930f414180d43c2d3287dd6d94bad31a710a", "13436": "148ddbd49454d48713a831d2b7a3e9621aafaf22", "13933": "ad04ee8ce91fde193fe4627f666ddeb52271a383", "14622": "297b15095e75da1566018a63b23a86031b90dfa5", "15096": "2fd6665664f27dfbf1f10aeeba660adc9b560361", "16113": "72e810f01ddd05aa28573edf9aedbaad6ddc2a98", "16441": "9ddfa7259de3053a5ed6655cd662e115926cf6a5", "17035": "98a3ee060b55aa073118885d11cc6a1cecd95059", "17352": "e19b37dcb74cc3819b5b60c49f0917f958c7aacb", "17515": "9c29e3376243b643a72f78b8b98a56d12c2e99bb", "17879": "aa480cedef435f179e0daff15700fb731abaa3b3", "18921": "17d4b53d2bdb3a7722530eef9be1d58b305c9a0d", "19165": "321494420f95c7a5e2172108400194b37a02e628", "19898": "5734dba905a275ec03dbcc39344a4e0a7e0e3b11", "20572": "960589c05b6a63ed612f2feb749ee4472e5aa43f", "20879": "829778b143967cb469e69e024ee5a7c71f17c782", "21750": "a950195e83d6f9af64fa3166369427b8a58d1066", "21854": "a01664f2ee155199d4ab7b234017912465ff62f7", "22103": "4f4730163097457cf9ddb5674ffd158ee8fa822e", "22973": "66520a91a421c1b93ece5dcd8af4b15d6f0edcb1", "24189": "c3e83212e4b5839cf1c41b91f1595f17925d48f3", "24648": "04be71faa15194e41e9455ca87d3b4427580ff42", "25153": "5f77694c6ee79184a85848ae70245eed4d80c881", "25365": "7a8cd0ee7161c4ea5ce4c2df248f0113890e3070", "26179": "994a2d1a452d233392c05a689ad2582a26558a53", "27420": "ec92c4c77d0f6ecffb896b2f7e118254c1b8db17"}, "revision_to_date": {"2709": 1418230434000, "2778": 1420549006000, "3092": 1423231525000, "3252": 1424962556000, "3288": 1425241693000, "3833": 1431422502000, "4133": 1436805783000, "4147": 1436809042000, "4152": 1436822856000, "6154": 1449989642000, "6158": 1450037476000, "6347": 1454669989000, "6419": 1455901486000, "6717": 1460014138000, "6989": 1465833321000, "7188": 1470640110000, "7314": 1474229287000, "7317": 1474234602000, "7319": 1474236389000, "7902": 1487873310000, "8201": 1492333110000, "8313": 1497973232000, "8727": 1511124255000, "8908": 1520845675000, "9015": 1528975233000, "9433": 1533297106000, "9477": 1533412829000, "9757": 1539100481000, "9910": 1539795151000, "10115": 1542383346000, "10615": 1555061395000, "10929": 1555511042000, "11849": 1571671069000, "11904": 1572366013000, "11988": 1573476398000, "12194": 1575895643000, "12308": 1579697801000, "12417": 1582628389000, "13436": 1605181574000, "13933": 1615381867000, "14622": 1623848591000, "15096": 1631803227000, "16113": 1643385906000, "16441": 1649853487000, "17035": 1661339897000, "17352": 1669373247000, "17515": 1673011490000, "17879": 1677576998000, "18921": 1681294690000, "19165": 1682602926000, "19898": 1691054134000, "20572": 1695985518000, "20879": 1697795708000, "21750": 1706515599000, "21854": 1708935913000, "22103": 1712652089000, "22973": 1726060594000, "24189": 1731922456000, "24648": 1733141217000, "25153": 1734099994000, "25365": 1734693757000, "26179": 1738049634000, "27420": 1743002529000}, "params": {"arch": ["x86_64"], "cpu": ["AMD EPYC 7763 64-Core Processor"], "machine": ["fv-az1198-574"], "num_cpu": ["4"], "os": ["Linux 6.8.0-1021-azure"], "ram": ["16373788"], "python": ["3.9"], "numpy": ["1.22.4"], "scipy": ["1.8.0"], "joblib": ["1.2.0"], "pandas": ["2.2.0"], "scikit-learn": ["1.4.0"], "nibabel": ["5.2.0"], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1198-574", "num_cpu": "4", "os": "Linux 6.8.0-1021-azure", "ram": "16373788", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}], "benchmarks": {"comparisons.image.CompareLoad.peakmem_compare_load": {"code": "class CompareLoad:\n    def peakmem_compare_load(self, loader):\n        \"\"\"Peak memory of loading images.\"\"\"\n        load(loader)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "comparisons.image.CompareLoad.peakmem_compare_load", "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "3393740643191f76a29d308527385e2193f76115a50909037fe16e954ffb1db3"}, "comparisons.image.CompareLoad.time_compare_load": {"code": "class CompareLoad:\n    def time_compare_load(self, loader):\n        \"\"\"Time the loading of images.\"\"\"\n        load(loader)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "comparisons.image.CompareLoad.time_compare_load", "number": 0, "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "d0f6bbea6406b5d2a9b78b4376f290309f6669c041393740442ad308a8205d67", "warmup_time": -1}, "comparisons.image.CompareMean.peakmem_compare_mean": {"code": "class CompareMean:\n    def peakmem_compare_mean(self, loader):\n        \"\"\"Peak memory of loading followed by taking the mean.\"\"\"\n        img = load(loader)[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "comparisons.image.CompareMean.peakmem_compare_mean", "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "15421e0fb233fb1f09563fc57931acc6f19b316cb0ea02ec7c81b26fc9801e57"}, "comparisons.image.CompareMean.time_compare_mean": {"code": "class CompareMean:\n    def time_compare_mean(self, loader):\n        \"\"\"Time the loading followed by taking the mean.\"\"\"\n        img = load(loader)[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "comparisons.image.CompareMean.time_compare_mean", "number": 0, "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "372b66141c4915e5bed9c8a824a440b875b0767c54fe1a652a661145d21bb5ab", "warmup_time": -1}, "comparisons.image.CompareSlice.peakmem_compare_slice": {"code": "class CompareSlice:\n    def peakmem_compare_slice(self, loader):\n        \"\"\"Peak memory of loading the image followed by extracting a\n        slice of it.\n        \"\"\"\n        img = load(loader)[1]\n        img.dataobj[..., 0]\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "comparisons.image.CompareSlice.peakmem_compare_slice", "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "147669a40e2c9d937e9ab5c7b8769bdc625e61d1a45a8a4dd0004b5e565882fc"}, "comparisons.image.CompareSlice.time_compare_slice": {"code": "class CompareSlice:\n    def time_compare_slice(self, loader):\n        \"\"\"Time the loading the image followed by extracting a slice of it.\"\"\"\n        img = load(loader)[1]\n        img.dataobj[..., 0]\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "comparisons.image.CompareSlice.time_compare_slice", "number": 0, "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "b073c1dfb39dd39376abb60a70f951a04446831fb7f3a239f9f1c7069ed07c43", "warmup_time": -1}, "comparisons.maskers.CompareMask.peakmem_compare_mask": {"code": "class CompareMask:\n    def peakmem_compare_mask(self, implementation, loader):\n        \"\"\"Peak memory of loading and then masking.\"\"\"\n        mask, img = load(loader)\n        apply_mask(mask, img, implementation)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "comparisons.maskers.CompareMask.peakmem_compare_mask", "param_names": ["implementation", "loader"], "params": [["'nilearn'", "'numpy (ref)'"], ["'nilearn'", "'nibabel (ref)'"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "754b2b03d751cd0e1c6a376b4e66378ef262110b29b9bb4f7e88fd2743c1e98e"}, "comparisons.maskers.CompareMask.time_compare_mask": {"code": "class CompareMask:\n    def time_compare_mask(self, implementation, loader):\n        \"\"\"Time the loading and then masking.\"\"\"\n        mask, img = load(loader)\n        apply_mask(mask, img, implementation)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "comparisons.maskers.CompareMask.time_compare_mask", "number": 0, "param_names": ["implementation", "loader"], "params": [["'nilearn'", "'numpy (ref)'"], ["'nilearn'", "'nibabel (ref)'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "1d55dcaf0e1f7cebfe880c443c7010e1d3912298f2e6f574b8213b1e9ba426de", "warmup_time": -1}, "tracking.image.LoadImgBenchmark.peakmem_load_img": {"code": "class LoadImgBenchmark:\n    def peakmem_load_img(self):\n        \"\"\"Peak memory of loading images.\"\"\"\n        load(\"nilearn\")\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "tracking.image.LoadImgBenchmark.peakmem_load_img", "param_names": [], "params": [], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "4bda072ff04b5b4bb23c72854b877c7ee49107347e3335ecd6bd15a59edd0ffb"}, "tracking.image.LoadImgBenchmark.time_load_img": {"code": "class LoadImgBenchmark:\n    def time_load_img(self):\n        \"\"\"Time the loading of images.\"\"\"\n        load(\"nilearn\")\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "tracking.image.LoadImgBenchmark.time_load_img", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "0a59a55aeaebc99998d456bcc2e1cff82612e134f99ae9845def891ea7a6a37b", "warmup_time": -1}, "tracking.image.MeanImgBenchmark.peakmem_mean_img": {"code": "class MeanImgBenchmark:\n    def peakmem_mean_img(self):\n        \"\"\"Peak memory of loading followed by taking the mean.\"\"\"\n        img = load(\"nilearn\")[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "tracking.image.MeanImgBenchmark.peakmem_mean_img", "param_names": [], "params": [], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "7bc4161dca76ed2951ccbc87c8c1435949a55347a7cf2d562dec74ff9851b647"}, "tracking.image.MeanImgBenchmark.time_mean_img": {"code": "class MeanImgBenchmark:\n    def time_mean_img(self):\n        \"\"\"Time the loading followed by taking the mean.\"\"\"\n        img = load(\"nilearn\")[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "tracking.image.MeanImgBenchmark.time_mean_img", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "66ef2c9f2c44437db2d865c711f0b6a510059db26503c2864a594953803b21ba", "warmup_time": -1}, "tracking.maskers.NiftiMaskerBenchmark.peakmem_nifti_masker": {"code": "class NiftiMaskerBenchmark:\n    def peakmem_nifti_masker(self, smoothing_fwhm, detrend):\n        \"\"\"Peak memory for the loading (only with nilearn here) and then\n        masking with different parameters.\n        \"\"\"\n        mask, img = load(\"nilearn\")\n        apply_mask(\n            mask,\n            img,\n            \"nilearn\",\n            nifti_masker_params={\n                \"smoothing_fwhm\": smoothing_fwhm,\n                \"detrend\": detrend,\n            },\n        )\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "tracking.maskers.NiftiMaskerBenchmark.peakmem_nifti_masker", "param_names": ["smoothing_fwhm", "detrend"], "params": [["None", "6"], ["False", "True"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "a14fceed8ba6d819539e86ac59917e73a6dfd6b1f2590e0ce2d99d64ed65d104"}, "tracking.maskers.NiftiMaskerBenchmark.time_nifti_masker": {"code": "class NiftiMaskerBenchmark:\n    def time_nifti_masker(self, smoothing_fwhm, detrend):\n        \"\"\"Time the loading (only with nilearn here) and then masking with\n        different parameters.\n        \"\"\"\n        mask, img = load(\"nilearn\")\n        apply_mask(\n            mask,\n            img,\n            \"nilearn\",\n            nifti_masker_params={\n                \"smoothing_fwhm\": smoothing_fwhm,\n                \"detrend\": detrend,\n            },\n        )\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "tracking.maskers.NiftiMaskerBenchmark.time_nifti_masker", "number": 0, "param_names": ["smoothing_fwhm", "detrend"], "params": [["None", "6"], ["False", "True"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "113bad4fde2f777ae46d3e1fc62ceab426bf32082725962697f30b5e991d6400", "warmup_time": -1}}, "machines": {"fv-az1198-574": {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1198-574", "num_cpu": "4", "os": "Linux 6.8.0-1021-azure", "ram": "16373788", "version": 1}}, "tags": {"0.0.1b1": 11904, "0.1": 3092, "0.1.1": 3252, "0.1.2": 3288, "0.1.3": 3833, "0.1.4": 4133, "0.1.4.1post1": 4152, "0.10.0": 17515, "0.10.1": 19165, "0.10.1rc1": 17879, "0.10.2": 20572, "0.10.3": 21750, "0.10.4": 22103, "0.11.0": 24648, "0.11.1": 25365, "0.1b1": 2778, "0.2.0": 6154, "0.2.1": 6158, "0.2.2": 6347, "0.2.3": 6419, "0.2.4": 6717, "0.2.5": 6989, "0.2.5.1": 7188, "0.2.5.2": 7314, "0.2.5.3": 7317, "0.2.6": 7319, "0.3.0": 8201, "0.3.0b1": 7902, "0.3.1": 8313, "0.4.0": 8727, "0.4.1": 8908, "0.4.2": 9015, "0.5.0a": 9477, "0.5.0b": 9910, "0.5.1": 10615, "0.5.2": 10929, "0.6.0": 12194, "0.6.0a": 11849, "0.6.0a0": 11849, "0.6.0b0": 11988, "0.6.1": 12308, "0.6.2": 12417, "0.7.0": 13436, "0.7.1": 13933, "0.8.0": 14622, "0.8.1": 15096, "0.9.0": 16113, "0.9.1": 16441, "0.9.2": 17035, "pre-troubleshooting": 9433, "0.1a1": 2709, "debian/0.1.4+git3-1": 4147, "rel0.0.1b": 9757, "0.5.0": 10115}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}