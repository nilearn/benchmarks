{"project": "nilearn", "project_url": "https://nilearn.github.io", "show_commit_url": "https://github.com/nilearn/nilearn/commit/", "hash_length": 8, "revision_to_hash": {"1935": "58fb3d058907a709caed14946e3a3410c1240161", "1982": "fde10ae71ab9df9adb4e4b11d9dff8a0775bd8e7", "2183": "6854e29ba97ccd42b3052e5bf446077ef3558cf5", "2326": "5c9709cc131ed46913ed454a16cbb1e25bfa4592", "2360": "1bdb686ca238f9f147641870854a783579f7a1a5", "2758": "c6b03f2ea7c75a3d80ff25b2d6c1b7dfe9dc18a8", "3017": "22eb0c2949a4167e7796b11b71d2fcff7f9c94a9", "3026": "20a05bead3b3e7f5f5c49926b858cc7ea4b5413b", "3031": "4cacc465c12a38009c330d036f0d278d01724e8a", "4625": "c4898338cba608d37f552d4f3fffe1261e6a07bf", "4629": "4199ed9c8cc3ec548793c1c734bb846d173bee32", "4802": "e5fef38140a688b374b383db6296c12ea945786e", "4874": "96a3f0f72b4f25af771116251324cbec4c0d2055", "5076": "070d3929431897ec175b4b2c869826959dda85ab", "5284": "4988bd761e9ba98ac784d6f99c4a9adf3f79227f", "5447": "67278ac891b599e592ea33a049d89b47e2fc44ce", "5539": "22ac1ae6e9925ddefdb849cd2e6981e4d1947aeb", "5542": "f1cc501a9bc7aafecdbe1fa4047a0a8aa3fa541f", "5544": "c5895f6ea864f042683cdf24e517694785fdca10", "6011": "58d4a33ad5f0fca7004790717988a5232e195666", "6193": "d2b5a93567aa49dd246acac443415dad86130b2b", "6283": "a894d6d931fe7c2b9341dcad228d364ac9580cd3", "6656": "627be2dc74c793b4d489ba62931288d8b71ef401", "6819": "972b8c12ee021f9c362f9b1cd165610ad8f5172a", "6893": "b4f71e5cb31fb0bef2eb9e253706d486edcec95a", "7245": "0b013683b96df6f8fb0124467e820e1326a25489", "7288": "0d2d692938662d54f42ebc1fc67c8f9729bdb73f", "7551": "4be29274fae131b36052c7f1c087b10f7deec519", "7684": "05ca61701ede4e82989d94eaa8b1ef5909b9ccaf", "7874": "61f469058dd16f64df4bc95cdd0d29e44b55d020", "8264": "4ff9717a8d9faa873c2e4137e8445a76865e7c56", "8536": "bccf672b5bbd12274c0504b7c35c75058ccc7e70", "8980": "7e09df29d06153b7d198f9a5b7f607d1f5b999d6", "8994": "b74b496bade616be483449c6da33c7c87e27cc77", "9008": "0941897aca6f3073221fcd3483afe91b8305b27c", "9049": "5acb6570832f2870bdd77b0a71a3b063540de5f9", "9072": "324935c0f4a8743ad82e8a3a3052e010fb10b855", "9118": "9835930f414180d43c2d3287dd6d94bad31a710a", "9264": "148ddbd49454d48713a831d2b7a3e9621aafaf22", "9328": "ad04ee8ce91fde193fe4627f666ddeb52271a383", "9392": "297b15095e75da1566018a63b23a86031b90dfa5", "9449": "2fd6665664f27dfbf1f10aeeba660adc9b560361", "9567": "72e810f01ddd05aa28573edf9aedbaad6ddc2a98", "9596": "9ddfa7259de3053a5ed6655cd662e115926cf6a5", "9611": "e10a146c2a51e01ae609d2b55c7e6d764fa3c90e", "9655": "6559e118d0cc652abfb017f231be8d459ca35880", "9673": "98a3ee060b55aa073118885d11cc6a1cecd95059", "9699": "e19b37dcb74cc3819b5b60c49f0917f958c7aacb", "9722": "9c29e3376243b643a72f78b8b98a56d12c2e99bb", "9742": "68f4b48399dc8fa68293757bb9bffbba6ba1a20a", "9755": "aa480cedef435f179e0daff15700fb731abaa3b3", "9786": "3183e0551e66dd6e7134c535ae5528c2fe6f83b0", "9830": "17d4b53d2bdb3a7722530eef9be1d58b305c9a0d", "9866": "321494420f95c7a5e2172108400194b37a02e628", "9873": "7e7e1b68b61e265ce6f683726a60a6c5fa5e2538", "9918": "1b11edf5789813d20995e7744bc58f3a2b6bc4ea", "9970": "5734dba905a275ec03dbcc39344a4e0a7e0e3b11", "10013": "9ae81991b1e782fbcd9ea8d2742438394b3f54ba", "10057": "0d39ce2019941a206b265adb48e72456770b7409", "10067": "960589c05b6a63ed612f2feb749ee4472e5aa43f", "10101": "829778b143967cb469e69e024ee5a7c71f17c782", "10145": "9d8d3d60122369b5440c7b952a39ee659b0b4a6e", "10188": "b34307a80cb023174c6ceee41f0ff359f2bbbe3c", "10215": "a950195e83d6f9af64fa3166369427b8a58d1066", "10232": "a01664f2ee155199d4ab7b234017912465ff62f7", "10271": "4f4730163097457cf9ddb5674ffd158ee8fa822e", "10276": "d4425e91aa0ff90fc25fe1730c5fa0f3923b37e3", "10319": "18cdf2b9bfc72d62ba89d4a1219759ab21361e05", "10363": "66520a91a421c1b93ece5dcd8af4b15d6f0edcb1", "10407": "5a19df902ae36b0adaf03fd0a8adc3216cdbf107", "10451": "53694a0ed0e8b3364f5f1d7b4c390bb6d7169a36", "10494": "c3e83212e4b5839cf1c41b91f1595f17925d48f3", "10538": "eb33f137f099a5cc83340785cd0b4bb9722f22a9", "10557": "04be71faa15194e41e9455ca87d3b4427580ff42", "10582": "4d06091ca4eb2e019a77c4fdfe19f57e2055385d", "10625": "5f77694c6ee79184a85848ae70245eed4d80c881", "10646": "7a8cd0ee7161c4ea5ce4c2df248f0113890e3070", "10669": "4b7dacb444ed84dadcdacff717b365b8198d3156", "10713": "c06ff6091290d4f6aecd23fd9efc02a73f45816f", "10756": "994a2d1a452d233392c05a689ad2582a26558a53", "10800": "c3c239acac4121a34b3551120c751d8183904154", "10844": "3f8629c437e983b731a817e1c66497f6ef939eba", "10887": "ec92c4c77d0f6ecffb896b2f7e118254c1b8db17", "10890": "4f00d0a1895e9b9bbb838fa4f6bcc7617b88eaf9", "10891": "eee20d69fcbb69912ee02d61abb22290d7ece8aa", "10896": "5d4969e76d21890eb5c175ac9abebdec8f13a218", "10907": "9723e28763240077518429c2580d75bac8c49b66", "10921": "726bf42b6114808b00d4514e934b37bf81a7701e", "10926": "9df603df4fc8bf28fc07c56fa22a6e3eb8f93d73", "10929": "34ff77ac402c09a6f49284359defa6aa4de9b07f", "10932": "1fe57183d42a9df8c90ea6466ec3cb6b026e4bfd", "10933": "78f2567d37e77f1deda9a072f8f40cf32cbfed6a", "10942": "2293344d39913ff879a5cb843dd54da1a0345480", "10943": "27f47c21111e576b93e4eb01f4d50a79f4892986", "10947": "cd53125402610f1b250bd2a2dd22fb6e325d4536", "10957": "55beacb9dadd2d6270befa0c64c4445411deca67", "10972": "3081985d28ad961f98812aab1e8487f4b10da941", "10977": "e60fefda02fbd17e1fa6c41f1125bc76864c314f", "10987": "a5eea43548b0494eb115d81311481b7e9b50f970", "11001": "429850f06d6647636509f24b34e85a463d5d5f3f", "11020": "6c782b83548be966ce5bbc813b9b420b058789bd", "11021": "f391c8d7d24a41df1f50360236648405b15f15bc", "11033": "d2a9c131ae6796bee56015b2b0a10af86718d46a", "11042": "0306200458f04424ae9a8e90646dad899eaaa3e0", "11049": "97631d9d527b7f88fa3d93c76681f828bb6e701c", "11051": "8789531e96b88a9e89c84e10b853410218d452a0", "11064": "73fe9520ea705056f89b1cd5982947de13d515a0", "11069": "35ab6c6eb2722a053fda839349c28188e6b3cb72", "11086": "5781114a235a43733a951535726a556432da0402", "11101": "0ba67f36ae8aa31f92a58ab114aab1876e10c299", "11107": "4c76adf58b6b48cdbd3e2cfa9e848f3a9324e570"}, "revision_to_date": {"1935": 1418230434000, "1982": 1420549006000, "2183": 1423231525000, "2326": 1424962556000, "2360": 1425241693000, "2758": 1431422502000, "3017": 1436805783000, "3026": 1436809042000, "3031": 1436822856000, "4625": 1449989642000, "4629": 1450037476000, "4802": 1454669989000, "4874": 1455901486000, "5076": 1460014138000, "5284": 1465833321000, "5447": 1470640110000, "5539": 1474229287000, "5542": 1474234602000, "5544": 1474236389000, "6011": 1487873310000, "6193": 1492333110000, "6283": 1497973232000, "6656": 1511124255000, "6819": 1520845675000, "6893": 1528975233000, "7245": 1533297106000, "7288": 1533412829000, "7551": 1539100481000, "7684": 1539795151000, "7874": 1542383346000, "8264": 1555061395000, "8536": 1555511042000, "8980": 1571671069000, "8994": 1572366013000, "9008": 1573476398000, "9049": 1575895643000, "9072": 1579697801000, "9118": 1582628389000, "9264": 1605181574000, "9328": 1615381867000, "9392": 1623848591000, "9449": 1631803227000, "9567": 1643385906000, "9596": 1649853487000, "9611": 1652631461000, "9655": 1659448310000, "9673": 1661339897000, "9699": 1669373247000, "9722": 1673011490000, "9742": 1676451905000, "9755": 1677576998000, "9786": 1678461362000, "9830": 1681294690000, "9866": 1682602926000, "9873": 1686048975000, "9918": 1688564962000, "9970": 1691054134000, "10013": 1693336472000, "10057": 1695696994000, "10067": 1695985518000, "10101": 1697795708000, "10145": 1702123512000, "10188": 1704815268000, "10215": 1706515599000, "10232": 1708935913000, "10271": 1712652089000, "10276": 1712824079000, "10319": 1718950571000, "10363": 1726060594000, "10407": 1728566458000, "10451": 1729756896000, "10494": 1731922456000, "10538": 1732700537000, "10557": 1733141217000, "10582": 1733259187000, "10625": 1734099994000, "10646": 1734693757000, "10669": 1735237165000, "10713": 1736959083000, "10756": 1738049634000, "10800": 1739791739000, "10844": 1741708341000, "10887": 1743002529000, "10890": 1743405226000, "10891": 1743429333000, "10896": 1743582834000, "10907": 1744017797000, "10921": 1744725247000, "10926": 1744886084000, "10929": 1745310652000, "10932": 1745583389000, "10933": 1745871984000, "10942": 1746178098000, "10943": 1746435313000, "10947": 1747041973000, "10957": 1747327772000, "10972": 1747985499000, "10977": 1748358090000, "10987": 1749229885000, "11001": 1749903656000, "11020": 1750489127000, "11021": 1750662461000, "11033": 1751266034000, "11042": 1751869678000, "11049": 1752224430000, "11051": 1753211945000, "11064": 1754650581000, "11069": 1755235733000, "11086": 1755875755000, "11101": 1756710981000, "11107": 1756824060000}, "params": {"arch": ["x86_64"], "cpu": ["AMD EPYC 7763 64-Core Processor"], "machine": ["fv-az1113-357"], "num_cpu": ["4"], "os": ["Linux 6.8.0-1021-azure", "Linux 6.8.0-1025-azure", "Linux 6.8.0-1026-azure", "Linux 6.8.0-1027-azure", "Linux 6.8.0-1029-azure", "Linux 6.8.0-1030-azure", "Linux 6.8.0-1031-azure"], "ram": ["16373752", "16373756", "16373784", "16373792", "16379880", "16379884", "16379888"], "python": ["3.9"], "numpy": ["1.22.4"], "scipy": ["1.8.0"], "joblib": ["1.2.0"], "pandas": ["2.2.0"], "scikit-learn": ["1.4.0"], "nibabel": ["5.2.0"], "branch": ["main"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1021-azure", "ram": "16373792", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1026-azure", "ram": "16373784", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1029-azure", "ram": "16379884", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1027-azure", "ram": "16373752", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1025-azure", "ram": "16373784", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1031-azure", "ram": "16379888", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1031-azure", "ram": "16379884", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1029-azure", "ram": "16379880", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1027-azure", "ram": "16373756", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}, {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1030-azure", "ram": "16379884", "python": "3.9", "numpy": "1.22.4", "scipy": "1.8.0", "joblib": "1.2.0", "pandas": "2.2.0", "scikit-learn": "1.4.0", "nibabel": "5.2.0", "branch": "main"}], "benchmarks": {"comparisons.image.CompareLoad.peakmem_compare_load": {"code": "class CompareLoad:\n    def peakmem_compare_load(self, loader):\n        \"\"\"Peak memory of loading images.\"\"\"\n        load(loader)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "comparisons.image.CompareLoad.peakmem_compare_load", "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "3393740643191f76a29d308527385e2193f76115a50909037fe16e954ffb1db3"}, "comparisons.image.CompareLoad.time_compare_load": {"code": "class CompareLoad:\n    def time_compare_load(self, loader):\n        \"\"\"Time the loading of images.\"\"\"\n        load(loader)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "comparisons.image.CompareLoad.time_compare_load", "number": 0, "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "d0f6bbea6406b5d2a9b78b4376f290309f6669c041393740442ad308a8205d67", "warmup_time": -1}, "comparisons.image.CompareMean.peakmem_compare_mean": {"code": "class CompareMean:\n    def peakmem_compare_mean(self, loader):\n        \"\"\"Peak memory of loading followed by taking the mean.\"\"\"\n        img = load(loader)[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "comparisons.image.CompareMean.peakmem_compare_mean", "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "15421e0fb233fb1f09563fc57931acc6f19b316cb0ea02ec7c81b26fc9801e57"}, "comparisons.image.CompareMean.time_compare_mean": {"code": "class CompareMean:\n    def time_compare_mean(self, loader):\n        \"\"\"Time the loading followed by taking the mean.\"\"\"\n        img = load(loader)[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "comparisons.image.CompareMean.time_compare_mean", "number": 0, "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "372b66141c4915e5bed9c8a824a440b875b0767c54fe1a652a661145d21bb5ab", "warmup_time": -1}, "comparisons.image.CompareSlice.peakmem_compare_slice": {"code": "class CompareSlice:\n    def peakmem_compare_slice(self, loader):\n        \"\"\"Peak memory of loading the image followed by extracting a\n        slice of it.\n        \"\"\"\n        img = load(loader)[1]\n        img.dataobj[..., 0]\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "comparisons.image.CompareSlice.peakmem_compare_slice", "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "147669a40e2c9d937e9ab5c7b8769bdc625e61d1a45a8a4dd0004b5e565882fc"}, "comparisons.image.CompareSlice.time_compare_slice": {"code": "class CompareSlice:\n    def time_compare_slice(self, loader):\n        \"\"\"Time the loading the image followed by extracting a slice of it.\"\"\"\n        img = load(loader)[1]\n        img.dataobj[..., 0]\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "comparisons.image.CompareSlice.time_compare_slice", "number": 0, "param_names": ["loader"], "params": [["'nilearn'", "'nibabel (ref)'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "b073c1dfb39dd39376abb60a70f951a04446831fb7f3a239f9f1c7069ed07c43", "warmup_time": -1}, "comparisons.maskers.CompareMask.peakmem_compare_mask": {"code": "class CompareMask:\n    def peakmem_compare_mask(self, implementation, loader):\n        \"\"\"Peak memory of loading and then masking.\"\"\"\n        mask, img = load(loader)\n        apply_mask(mask, img, implementation)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "comparisons.maskers.CompareMask.peakmem_compare_mask", "param_names": ["implementation", "loader"], "params": [["'nilearn'", "'numpy (ref)'"], ["'nilearn'", "'nibabel (ref)'"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "754b2b03d751cd0e1c6a376b4e66378ef262110b29b9bb4f7e88fd2743c1e98e"}, "comparisons.maskers.CompareMask.time_compare_mask": {"code": "class CompareMask:\n    def time_compare_mask(self, implementation, loader):\n        \"\"\"Time the loading and then masking.\"\"\"\n        mask, img = load(loader)\n        apply_mask(mask, img, implementation)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "comparisons.maskers.CompareMask.time_compare_mask", "number": 0, "param_names": ["implementation", "loader"], "params": [["'nilearn'", "'numpy (ref)'"], ["'nilearn'", "'nibabel (ref)'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "1d55dcaf0e1f7cebfe880c443c7010e1d3912298f2e6f574b8213b1e9ba426de", "warmup_time": -1}, "tracking.image.LoadImgBenchmark.peakmem_load_img": {"code": "class LoadImgBenchmark:\n    def peakmem_load_img(self):\n        \"\"\"Peak memory of loading images.\"\"\"\n        load(\"nilearn\")\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "tracking.image.LoadImgBenchmark.peakmem_load_img", "param_names": [], "params": [], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "4bda072ff04b5b4bb23c72854b877c7ee49107347e3335ecd6bd15a59edd0ffb"}, "tracking.image.LoadImgBenchmark.time_load_img": {"code": "class LoadImgBenchmark:\n    def time_load_img(self):\n        \"\"\"Time the loading of images.\"\"\"\n        load(\"nilearn\")\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "tracking.image.LoadImgBenchmark.time_load_img", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "0a59a55aeaebc99998d456bcc2e1cff82612e134f99ae9845def891ea7a6a37b", "warmup_time": -1}, "tracking.image.MeanImgBenchmark.peakmem_mean_img": {"code": "class MeanImgBenchmark:\n    def peakmem_mean_img(self):\n        \"\"\"Peak memory of loading followed by taking the mean.\"\"\"\n        img = load(\"nilearn\")[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "tracking.image.MeanImgBenchmark.peakmem_mean_img", "param_names": [], "params": [], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "7bc4161dca76ed2951ccbc87c8c1435949a55347a7cf2d562dec74ff9851b647"}, "tracking.image.MeanImgBenchmark.time_mean_img": {"code": "class MeanImgBenchmark:\n    def time_mean_img(self):\n        \"\"\"Time the loading followed by taking the mean.\"\"\"\n        img = load(\"nilearn\")[1]\n        mean_img(img)\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "tracking.image.MeanImgBenchmark.time_mean_img", "number": 0, "param_names": [], "params": [], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "66ef2c9f2c44437db2d865c711f0b6a510059db26503c2864a594953803b21ba", "warmup_time": -1}, "tracking.maskers.NiftiMaskerBenchmark.peakmem_nifti_masker": {"code": "class NiftiMaskerBenchmark:\n    def peakmem_nifti_masker(self, smoothing_fwhm, detrend):\n        \"\"\"Peak memory for the loading (only with nilearn here) and then\n        masking with different parameters.\n        \"\"\"\n        mask, img = load(\"nilearn\")\n        apply_mask(\n            mask,\n            img,\n            \"nilearn\",\n            nifti_masker_params={\n                \"smoothing_fwhm\": smoothing_fwhm,\n                \"detrend\": detrend,\n            },\n        )\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "name": "tracking.maskers.NiftiMaskerBenchmark.peakmem_nifti_masker", "param_names": ["smoothing_fwhm", "detrend"], "params": [["None", "6"], ["False", "True"]], "setup_cache_key": "common:14", "type": "peakmemory", "unit": "bytes", "version": "a14fceed8ba6d819539e86ac59917e73a6dfd6b1f2590e0ce2d99d64ed65d104"}, "tracking.maskers.NiftiMaskerBenchmark.time_nifti_masker": {"code": "class NiftiMaskerBenchmark:\n    def time_nifti_masker(self, smoothing_fwhm, detrend):\n        \"\"\"Time the loading (only with nilearn here) and then masking with\n        different parameters.\n        \"\"\"\n        mask, img = load(\"nilearn\")\n        apply_mask(\n            mask,\n            img,\n            \"nilearn\",\n            nifti_masker_params={\n                \"smoothing_fwhm\": smoothing_fwhm,\n                \"detrend\": detrend,\n            },\n        )\n\nclass Benchmark:\n    def setup_cache(self, n_subjects=10, n_masks=1):\n        \"\"\"Set up the cache directory with the necessary images and masks.\n    \n        The fMRI image is created by concatenating n_subjects subject images\n        from :func:`nilearn.datasets.fetch_adhd`. The masks are created by\n        resampling the atlas from\n        :func:`nilearn.datasets.fetch_atlas_basc_multiscale_2015` to the fMRI\n        image and then creating masks for each region in the atlas.\n    \n        Parameters\n        ----------\n        n_subjects : int, optional, default=10\n            The number of subject images concatenated together to create the\n            fMRI image.\n        n_masks : int, optional, default=1\n            The number of masks to create.\n        \"\"\"\n        # get an image\n        fmri_data = fetch_adhd(n_subjects=n_subjects)\n        concat = concat_imgs(fmri_data.func)\n        concat.to_filename(f\"fmri_{n_subjects}.nii.gz\")\n    \n        # get a mask\n        atlas_path = fetch_atlas_schaefer_2018(n_rois=100).maps\n        resampled_atlas = resample_to_img(\n            atlas_path,\n            concat,\n            interpolation=\"nearest\",\n            force_resample=True,\n        )\n        for idx in range(1, n_masks + 1):\n            mask = resampled_atlas.get_fdata() == idx\n            mask_img = new_img_like(\n                resampled_atlas,\n                mask,\n                affine=resampled_atlas.affine,\n                copy_header=True,\n            )\n            mask_img.to_filename(f\"mask_{idx}.nii.gz\")", "min_run_count": 2, "name": "tracking.maskers.NiftiMaskerBenchmark.time_nifti_masker", "number": 0, "param_names": ["smoothing_fwhm", "detrend"], "params": [["None", "6"], ["False", "True"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "setup_cache_key": "common:14", "type": "time", "unit": "seconds", "version": "113bad4fde2f777ae46d3e1fc62ceab426bf32082725962697f30b5e991d6400", "warmup_time": -1}}, "machines": {"fv-az1113-357": {"arch": "x86_64", "cpu": "AMD EPYC 7763 64-Core Processor", "machine": "fv-az1113-357", "num_cpu": "4", "os": "Linux 6.8.0-1031-azure", "ram": "16379888", "version": 1}}, "tags": {"0.0.1b1": 8994, "0.1": 2183, "0.1.1": 2326, "0.1.2": 2360, "0.1.3": 2758, "0.1.4": 3017, "0.1.4.1post1": 3031, "0.10.0": 9722, "0.10.1": 9866, "0.10.1rc1": 9755, "0.10.2": 10067, "0.10.3": 10215, "0.10.4": 10271, "0.11.0": 10557, "0.11.1": 10646, "0.12.0": 11020, "0.12.1": 11107, "0.1b1": 1982, "0.2.0": 4625, "0.2.1": 4629, "0.2.2": 4802, "0.2.3": 4874, "0.2.4": 5076, "0.2.5": 5284, "0.2.5.1": 5447, "0.2.5.2": 5539, "0.2.5.3": 5542, "0.2.6": 5544, "0.3.0": 6193, "0.3.0b1": 6011, "0.3.1": 6283, "0.4.0": 6656, "0.4.1": 6819, "0.4.2": 6893, "0.5.0a": 7288, "0.5.0b": 7684, "0.5.1": 8264, "0.5.2": 8536, "0.6.0": 9049, "0.6.0a": 8980, "0.6.0a0": 8980, "0.6.0b0": 9008, "0.6.1": 9072, "0.6.2": 9118, "0.7.0": 9264, "0.7.1": 9328, "0.8.0": 9392, "0.8.1": 9449, "0.9.0": 9567, "0.9.1": 9596, "0.9.2": 9673, "pre-troubleshooting": 7245, "0.1a1": 1935, "debian/0.1.4+git3-1": 3026, "rel0.0.1b": 7551, "0.5.0": 7874}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}